\subsection{Runtime view}
An important issue in the project is the process in which the user gives a reply to an individual request
performed by a third party customer. 
This is exploited in the following diagram, that assumes that the user
has already logged in and that the list of pending request is non-empty.

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/requestacceptance.pdf}
\caption{ Sequence diagram: request acceptance }
\label{fig:requestacceptance}
\end{figure}

Some comments follows in order to clarify some essential points:
\begin{itemize}
\item The API gateway functions also as a proxy for the authentication service. In particular, it keeps track of the active sessions of the
users (identified by a token\_id). This information is in memory since
it was returned from the account service in the moment in which that user has performed the log in
\item The communication between services is kept asynchronous, in order to not reduce the response time 
toward the user that initially used the individual request service. This is acceptable because there are
no strict requirement on the efficiency on the access of data by third party customer (i.e. the data should
not be available in the exact moment in which an user sends a response: some latency is tolerated). 
\item The share data service needs information about requests that have been accepted, in order to correctly
provide the data access in the right way (i.e. granting access if an accepted request on the data has been 
accepted). Therefore, when a request is assigned to a new status in the individual request service, this information is communicated
\end{itemize}


\par 
Another important feature is the fact that third party customers can perform requests on aggregated data. \\


\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/grouprequest.pdf}
\caption{ Sequence diagram: group request }
\label{fig:grouprequest}
\end{figure}

The same comments of the previous diagram hold, also, in this situation. 
However, it is relevant to clarify the asynchronous exchange of messages that happens between the group request service and the share data
service. 
In the first place, it is necessary to point out that when a third party customer sends a group request, it is reasonable to assume that 
some time to serve and verify the request can be taken, but a non-desired behavior is to block the client in waiting the response. The status
of the request can be checked in a second moment, always via the group request service. 
Therefore, when a petitioner asks for some aggregated data, the group request service will delegate to the share data service the task of 
analyzing the request: it will then reply with the number of user involved. If this number is greater than 1000, the group request service
change the status of the request from "under analysis" to "accepted" and it will send this information to the share data service, that, thus,
will be able to provide correct access to the requested data. \\

\par 
A critical feature of the project is the the one that regards AutomatedSOS: 

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/automatedsos.pdf}
\caption{ Sequence diagram: automated SOS call}
\label{fig:automatedSOScall}
\end{figure}

This feature is implemented locally, in the mobile application, in order to guarantee the best efficiency and reduce to the minimum delays
that may be introduced due to data transfer over the Internet. 
Indeed, the diagrams shows that the user hardware device component will collect user health data, and send them to the user application: if this observes some parameters below the threshold, it will perform an SOS call. 
The call is handled in the following way: the mobile app uses a default template to communicate with an emergency room operator all the
information needed to provide assistance (i.e. health data and position). 
The emergency room operator, replies with a response that should be "Yes" or "No", in order that the application is aware of it.  \\

\par 
The log in is an important feature of large interest, because it is also central for the process of handling the users' session. The next
diagram expose the procedure for the user.

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/login.pdf}
\caption{ Sequence diagram: log in}
\label{fig:login}
\end{figure}

As the diagram show, if the log in is done correctly, a token is generated from the account service and returned back to the API gateway
and to the client. 
The information will be used by both the client and the API gateway to manage the user session: all the next requests will be authenticated
using that token.  \\

\par 
The procedure of closing a race is here described: 

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/closerace.pdf}
\caption{ Sequence diagram: close race}
\label{fig:closerace}
\end{figure}

It is worth to comment the asynchronous message from race service to spectator service. 
Indeed, in this case the race is successfully closed, therefore, data collection from athletes from that event should be stopped and not 
more available; and the same holds for the fact that user are no more able to see their positions, but only the leaderboard.
In order to accomplish this, an asynchronous call is here performed, to inform the spectator service. 
Note that some delay could happen, due to asynchronicity, in preventing the above mentioned features; however this is tolerated, because
it is not something considered that critical.

\par
The interaction between components during the send of cluster of data done by a user is described as follows:

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/senddata.pdf}
\caption{ Sequence diagram: send cluster of data}
\label{fig:closerace}
\end{figure}

The most of the request done by users is related to sending data to the TrackMe system. Therefore, this is one of the bottleneck 
of the system. By taking into consideration that more or less every application server accepts about 8Kb of header HTTP request, 
then it means that having 
