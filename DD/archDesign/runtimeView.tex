\subsection{Runtime view}
An important issue in the project is the process in which the user gives a reply to an individual request
performed by a third party customer. This is exploited in the following diagram, that assumes that the user
has already logged in and that the list of pending request is non-empty.

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/requestacceptance.pdf}
\caption{ Sequence diagram: request acceptance }
\label{fig:world2}
\end{figure}

Some comments follows in order to clarify some essential points:
\begin{itemize}
\item The API gateway functions also as a proxy for the authentication service. In particular, it keeps track of the active sessions of the
users (identified by a token\_id). This information is in memory since
it was returned from the account service in the moment in which that user has performed the log in
\item The communication between services is kept asynchronous, in order to not reduce the response time 
toward the user that initially used the individual request service. This is acceptable because there are
no strict requirement on the efficiency on the access of data by third party customer (i.e. the data should
not be available in the exact moment in which an user sends a response: some latency is tolerated). 
\item The share data service needs information about requests that have been accepted, in order to correctly
provide the data access in the right way (i.e. granting access if an accepted request on the data has been 
accepted). Therefore, when a request is assigned to a new status in the individual request service, this information is communicated
\end{itemize}


\par 
Another important feature is the fact that third party customers can perform requests on aggregated data. \\


\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/grouprequest.pdf}
\caption{ Sequence diagram: group request }
\label{fig:world2}
\end{figure}

The same comments of the previous diagram hold, also, in this situation. 
However, it is relevant to clarify the asynchronous exchange of messages that happens between the group request service and the share data
service. 
In the first place, it is necessary to point out that when a third party customer sends a group request, it is reasonable to assume that 
some time to serve and verify the request can be taken, but a non-desired behavior is to block the client in waiting the response. The status
of the request can be checked in a second moment, always via the group request service. 
Therefore, when a petitioner asks for some aggregated data, the group request service will delegate to the share data service the task of 
analyzing the request: it will then reply with the number of user involved. If this number is greater than 1000, the group request service
change the status of the request from "under analysis" to "accepted" and it will send this information to the share data service, that, thus,
will be able to provide correct access to the requested data. \\

\par 
A critical feature of the project is the the one that regards AutomatedSOS: 

\begin{figure}[H]
\includegraphics[width=\linewidth]{Images/automatedsos.pdf}
\caption{ Sequence diagram: group request }
\label{fig:world2}
\end{figure}

This feature is implemented locally, in the mobile application, in order to guarantee the best efficiency and reduce to the minimum delays
that may be introduced due to data transfer over the Internet. Indeed, the diagrams shows that the user hardware device component will collect
user health data, and send them to the user application: if this observes some parameters below the threshold, it will perform an SOS
call. The call is handled in the following way: the mobile app uses a default template to communicate with an emergency room operator all the
information needed to provide assistance (i.e. health data and position). The emergency room operator, replies with a response that should be "Yes" or "No", in order that the application is aware of it. 
